\HC[All]{en cours}

Distributed software commissioning is somewhere between the components'
development (functional part) and the running state of the distributed software
on the infrastructure (management part). As a result, the particularity of a
distributed software commissioning is that it needs information both from the
components behaviors and from the underlying infrastructure on which each
component will be executed. For this reason, multiple human actors are often
involved in the commissioning procedure: developers, system administrators and
system operators. This frontier is often called the DevOps domain where the
commissioning fits in. Note that our definition of software commissioning does
not include dynamic reconfiguration aspects of the distributed software management that is left to future work.

When designing distributed software, first, the code of each component is
written by a given \emph{developer}, and this developer often also codes a set
of \emph{control interfaces} to act on the component. Examples of control
interfaces could be \texttt{start}, \texttt{stop} or \texttt{update}, for
instance. Most of the time such control interfaces take part in the component
commissioning. However, they are not sufficient as they only serve the component
level, not the infrastructure level, nor the configuration level.
\emph{Configuration files} are often used additionally as \emph{configuration
	interfaces} to get information from system administrators or operators that
cannot be known in advance when writing the functional code of the component.
\CP{où est le second?} Thirdly, components often require a set of packages or
libraries to be installed on the host operating system to work properly. Those
requirements are directly related to the \emph{infrastructure management} as
some of them may already be installed on machines. %In the end, the overall
% commissioning procedure
%of a single software component is complex because it juggles with the
%control interfaces, infrastructure interfaces and infrastructure
%management information. In other words,
In the end, the commissioning procedure of a single component is a
\emph{coordination program} between different DevOps interfaces. Commissioning
procedures are often explained in \texttt{README} files, or in
documentation\footnote{\url{https://doc.ubuntu-fr.org/apache2}}. %
% correction: documentations (plural) is very uncommon, the
% uncountable form is preferred
%
When considering a complete distributed software composed of a set of
components, the picture becomes even more complex as it is needed to coordinate
the commissioning procedure of all the components together with their associated
interactions. For instance, when installing a very basic Apache/MariaDB system,
additional documentation is
required\footnote{\url{https://doc.ubuntu-fr.org/lamp}} to combine the Apache
component with the MariaDB component. Another example could be the commissioning
of Spark on top of
Yarn\footnote{\url{https://spark.apache.org/docs/latest/running-on-yarn.html}}.

\CP{Cela me gène car les gens utilisent des distributions linux par exemple pour
	se simplifier la vie.}

%%% the three important metrics of this contribution
In this paper, three metrics are considered important regarding the quality of
the automation of distributed software commissioning: (1) a clear separation of
concerns between the different actors of the commissioning procedure (\ie
developers and system administrators) to enhance productivity, maintainability
and reusability of commissioning codes; (2) the efficiency of the commissioning
procedure in terms of parallelism expressivity; and (3) the formalization of
the solution such that formal properties can be proven on a given
commissioning procedure. The contribution of this paper improves the related
work by suceeding in the combination of these three metrics.

%%% precision on the efficiency
Improving the efficiency of distributed software commissioning may seem useless
as this procedure is executed once and for all. However, this claim does not
consider the problem as a whole and needs clarification. %
First, the commissioning procedure of complex distributed software such as
OpenStack (Section~\ref{sec:use-cases}) can take from 15 minutes to more than
one hour to finish, thus gaining in speed is significant. Second, a system
administrator does not perform the commissioning process only once. When new
machines or new clusters are installed in their infrastructure, when errors
occur, or when updates are needed, commissioning procedures are executed again.
In addition to this, having an efficient commissioning procedure is a first step
toward efficient reconfigurations of dynamic software systems (\eg self-adaptive
systems) and dynamic infrastructures (\eg edge computing) where disruption time
of services must be minimized. % experiments and continuous integration
Furthermore, there are two specific contexts where distributed software
commissionings are extensively executed: \emph{experiments} (research or
industry) and \emph{continuous integration} of distributed software systems. For
instance, by exploring the traces of the OpenStack CI
platform\footnote{\url{http://logstash.openstack.org}}, we have observed that
the OpenStack commissioning is often called, although irregularly. Figure~\ref{}
shows the recorded deployments of OpenStack during a year where variations can
be observed. The highest peak represents XXX commissionings of OpenStack in 24
hours. %
\HC[Helene]{à terminer et améliorer avec nouvelles traces}

Many different techniques could be studied to improve the efficiency of distributed software commissionings such as for instance: using optimized and adapted system commands in commissioning scripts and programs (\eg \texttt{rsync} instead of many \texttt{scp}); working on the optimization of a given system command (\eg \nix package manager instead of \texttt{apt-get}); if using virtual images or container images, improving the boot time of hypervisors~\cite{nguyen:hal-02172288}; if using \docker images, optimizing the placement of image layers on the network~\cite{darrous:hal-01745405}; exposing more parallelism in commissioning languages~\cite{dicosmo:hal-01233489}. The scope of this paper is to study this last option, in other words how to improve the parallelism expressiveness of commissioning tools and languages.