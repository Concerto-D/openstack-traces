% 1. introduce metrics of RW
% - soft. eng., composition, code reuse, sep of concerns
% - parallelism levels
% 2. RW analyze
% - each tool
% - table
% 3. discussion
% - intra-task
% - performance model

%----------------------------
\subsection{Automation of distributed software commissioning}
%----------------------------
% 1. scripting
% 2. infrastructure as code
% 3. provisioning tools
% 4. orchestration tools
% 5. scope of the paper
% - software commissioning of a single distributed software
% - generic solution that could use or not provisioning tools
% - scripting/IaC but keep Kubernetes and Juju

Four classes of tools and languages can be considered regarding
automating and enhancing software engineering properties
of commissioning procedures.

\paragraph{Scripting/coding languages}
First, a common way of automating commissioning procedures is to use
\emph{scripting languages} such as \shell or \ruby for instance. Such
languages are very flexible and well known by system administrators
and operators but suffer from many limitations, particularly from a
software engineering standpoint. In particular, they are not well
suited to deal with separation of concerns, composition and complex
coordination mechanisms.

\paragraph{Software configuration tools}
A second class of languages and tools is called \emph{software
  configuration tools}. This class contains the set of quite recent
DevOps tools such as \ansible~\cite{ansible:web},
\puppet~\cite{puppet:web}, \chef~\cite{chef:web},
\salt~\cite{salt:web}, as well as some academic contributions
\deployware~\cite{flissi2008ccgrid},
\aeolus~\cite{dicosmo2014ic,dicosmo:hal-01233489} etc. The goal of
these tools is to enhance the productivity when defining components or
services commissionings and the coordination of their tasks. Most of
the time these tools add an abstraction layer on top of scripting languages
to hide some of their technical details (\eg SSH connections). These
tools use different methods to achieve their goals. For instance,
Ansible adopts a procedural imperative style in YAML as a
series of tasks to execute, while Puppet adopts a declarative approach
in Python by combining different instances of resources (\ie
services, packages, etc.). In a declarative approach the user describes
what is needed rather than how to get it, which is left to the tool
developers. Such an approach enhances productivity but reduces
flexibility for the user.

\paragraph{Infrastructure definition tools}
Some tools, that are sometimes called \emph{infrastructure definition
  tools}~\cite{}, or \emph{provisioning tools}, have been specifically
designed to be able to handle complex distributed infrastructures
composed of multiple clusters and multiple machines shared between
users. Managing such infrastructure is very difficult and error prone
as each application and each user may possibly need different
requirements, different operating systems, different package versions,
etc. Virtualization has partly been introduced to enhance
infrastructure management (in addition to improving portability of
applications, isolation between users, etc.). This type of tools, that
includes \docker~\cite{docker:web}, \terraform~\cite{terraform:web},
\juju~\cite{juju:web}, \cloudformation~\cite{cloudf:web} or
\heat~\cite{heat:web} for instance, uses virtualization mechanisms (\eg
virtual machines, containers) to reduce the commissioning process to a
set of commands allowing to deploy a virtual resource (by using an image) on a
physical machine. This technique potentially reduces the complexity of
the commissioning procedures if the needed image is already available,
otherwise the initial commissioning commands and coordination have to
be done to create the image. Some of these tools are specific to a
given virtualization technique (\eg \docker, \cloudformation and
\heat), while others offer \emph{providers} for different kinds of
Cloud infrastructures (\eg \terraform, \juju). The \tosca
standard~\cite{tosca:web}, and its
implementations~\cite{Binz2013,cloudify:web,opentosca:web,8599581} can
be classified as a descriptive provisioning tool. More precisely,
\tosca is presented as a Cloud Modeling Language (CML).
%By using
%\tosca, a set of cloud-based services is modeled as a graph where each
%node represents a component of the application and each edge
%represents the relationship between components. \tosca allows for
%portability and automated management across cloud platforms and
%infrastructures. In \tosca, commissioning actions are scripts
%encapsulated in \emph{artifacts}.

\paragraph{Orchestration tools}
Finally, some recent tools go further by offering an
\emph{orchestration} level to handle shared clusters of machines
running many services simultaneously to orchestrate. In this case,
being able to deploy or install distributed software is only part of
the problem, as services also need to be restarted in case of failure, or
to be scaled in case of overload, etc. The famous
\kubernetes~\cite{kubernetes:web} enters in this category, as well as
\dockerswarm~\cite{dockerswarm:web}. If these tools are outside the
scope of this paper, a subdivision of their architecture handles
distributed software commissioning. For instance \kubernetes relies
on \docker for commissioning.

In pratice, these tools are often combined by system administrators
and operators to achieve both distributed software commissioning and
infrastructure management.

\begin{tcolorbox}[enhanced,attach boxed title to top left={yshift=-3mm,yshifttext=-1mm},
  colback=black!5!white,colframe=black!30,colbacktitle=black!60,
  title=Contribution,fonttitle=\bfseries,
  boxed title style={size=small,colframe=black!60,boxrule=0.2mm},
  boxrule=0.2mm]
  The contribution of this paper, \ie the Madeus model, specifically
  focuses on enhancing the procedural-oriented \emph{software
    configuration tools} by improving separation of concerns,
  composition and efficiency.
\end{tcolorbox}

Among the plethora of distributed software commissioning solutions, we
have selected a subset of them for a deeper comparison. We have
selected: two \emph{coding} or scripting solutions, \shell and
\fractal; three procedural-oriented solutions of the \emph{software
  configuration} class, \ansible, \deployware and \aeolus; two
solutions of the \emph{infrastructure definition} class, \juju and
\tosca; and finally one \emph{orchestration} solution, \kubernetes. In
this selection we have deliberately selected both production tools and
academic contributions. Moreover, we have selected production tools
with a significant opensource community.

%----------------------------
\subsection{Related work metrics}
%----------------------------
% 1. software engineering
% - components / service / module
% - sub-elements / tasks
% - separation of concerns when assembling 2 components, no need to
% know what each component does to commission itself
% 2. parallelism
% - node / SIMH
% - inter-component
% - inter-task
% - intra-task
% 3. formalism
% - formal model

Before introducing the related works of this paper, some analysis
metrics need to be introduced. These metrics are divided in three
sets: software engineering (SE) metrics, metrics related to the
parallelism level of commissioning, and metrics related to formal
aspects of commissioning. For each metric, four levels will be
considered and presented in Table~\ref{tab:comparison}: (1) supported,
denoted with \checkmark, that counts for 3 points in the score; (2)
partially supported, denoted (\checkmark), that counts for 2 points;
(3) manually supported, denoted \emph{M}, meaning that the user may
code manually the given metric, and that counts 1 point; and finally
(4) not supported, denoted -.

\paragraph{Software engineering}
As introduced in the previous section, when automating distributed
software commissioning, one important aspect is to promote software
engineering properties. Indeed, when different actors are involved in
one given goal, software engineering techniques can help improving
separation of concerns (\ie code reuse, maintainability
etc.). Separation of concerns means that each actor is responsible for
her own specialism, \ie her own expertise domain. Such separation of
concerns is improved as soon as a modular or component-based approach
is adopted, \ie each actor could be responsible for one
component. Furthermore, component-based architectures are also equipped
with composition mechanisms that facilitate the interactions between the
different entities implemented by different actors. One additional
actor may also enter the picture to design this composition. We define
three SE metrics to compare the related works:
\begin{itemize}
\item \emph{component}: if the work (tool, framework or scientific
  contribution) offers a component-oriented (\eg services, modules)
  structure of commissionings;
\item \emph{tasks}: if the work (tool, framework or scientific
  contribution) offers a way to divide the commissioning of each
  component in sub-elements that we call \emph{tasks} and that promote
  an better structured procedural design;
\item \emph{separation of concerns}: if the work (tool, framework or
  scientific contribution) offers a way to build distributed software
  commissionings by composing the commissioning of individual
  components without needing to know their internal behaviors.
\end{itemize}

\paragraph{Parallelism level}
A second important aspect of distributed software commissioning that
has been introduced in the previous section is its efficiency and in
particular (in this paper) the level of parallelism offered by
commissioning tools and frameworks. We consider four metrics to
compare the related work:
\begin{itemize}
\item \emph{SIMH}: if the work offers a transparent way to perform the
  same instruction or set of instructions on multiple hosts
  simultaneously, meaning that there are no dependencies between the
  instructions to be performed on the different hosts;
  \item \emph{inter-comp}: if the work offers a transparent way to
    simultaneously execute the commissionings of multiple components
    when no dependency exists between those components;
  \item \emph{inter-comp-tasks}: if the work offers a transparent way to
    simultaneously execute the commissioning tasks of multiple
    components until a dependency between multiple tasks is reached;
  \item \emph{intra-comp-tasks}: if the work offers a way to simultaneously
    execute two commissioning tasks of a given component, in other
    words if a partial order of tasks can be given for a component.
\end{itemize}
One can note that the level of parallelism offered by a given tool is
directly correlated to the type of dependencies that can be declared
by users. For instance, without any dependency mechanisms, the best
possible level would be SIMH, while for \emph{inter-comp} dependencies
or \emph{inter-comp-tasks} dependencies, more parallelism could be
handled between components of different types.

Figure~\ref{fig:parlevels} illustrates the four parallelism levels
listed above through one example. In this example three components or modules are
depicted. The component $C$ is deployed on two hosts while components
$A$ and $B$ are deployed on a single host. Moreover, components $A$
and $B$ need to be coordinated while the component $C$ is independent
from both $A$ and $B$. First, Figure~\ref{fig:simh} displays
the \emph{SIMH} level, where parallelism can be introduced for the
component $C$. Second, Figure~\ref{fig:inter-comp} illustrates the
\emph{inter-comp} parallelism level. Indeed, as $C$ is independent from
$B$ both component commissionings can be performed
simultaneously. However, as component $B$ depends on component $A$,
and as the dependencies are only available at the component level,
their commissioning still has to be performed one after the
other. Third, Figure~\ref{fig:inter-comp-tasks} shows the
\emph{inter-comp-tasks} parallelism level, where dependencies can be
defined at the finer level of the tasks. In this case, the commissionings
of components $A$ and $B$ can be started in parallel until they reach
their dependencies. Thus, component $B$ has to wait for the component
$A$ to perform needed tasks before continuing its
commissioning. Finally, Figure~\ref{fig:intra-comp-tasks} illustrates
the \emph{intra-comp-tasks} parallelism level, where some tasks inside
a component can be performed in parallel. One can note that the
higher the number of supported parallelism levels is, the shorter
the commissioning time (represented by the height of the figures) is.

\begin{figure*}[t!]
  \begin{center}
    \subfloat[SIMH]{
      \fcolorbox{black!20}{white}{
        \begin{minipage}[c][7.5cm][c]{0.45\linewidth}%
          \centering
          \scalebox{0.43}{\input{./figures/simh.tex}}
        \end{minipage}
      }\label{fig:simh}
    }
    \subfloat[inter-comp]{
      \fcolorbox{black!20}{white}{
        \begin{minipage}[c][7.5cm][c]{0.45\linewidth}%
          \centering
          \scalebox{0.47}{\input{./figures/inter-comp.tex}}
        \end{minipage}
      } \label{fig:inter-comp}
    }
    \\

    \subfloat[inter-comp-tasks]{
      \fcolorbox{black!20}{white}{
        \begin{minipage}[c][5cm][c]{0.45\linewidth}%
          \centering
          \scalebox{0.47}{\input{./figures/inter-comp-tasks.tex}}
        \end{minipage}
      }\label{fig:inter-comp-tasks}
    }
    \subfloat[intra-comp-tasks]{
      \fcolorbox{black!20}{white}{
        \begin{minipage}[c][5cm][c]{0.45\linewidth}%
          \centering
          \scalebox{0.47}{\input{./figures/intra-comp-tasks.tex}}
        \end{minipage}
      } \label{fig:intra-comp-tasks}
    }
    \caption{Examples to illustrate the four parallelism levels
      considered in this paper}
    \label{fig:parlevels}
  \end{center}
\end{figure*}

One can note that presented metrics for both SE and parallelism are
procedural-oriented as they consider \emph{tasks} and not
\emph{resources}, thus excluding \puppet or \salt for instance. While
it is an approach with great advantages, declarative approaches are
not considered in this paper.

\paragraph{Formalism}
The last metric considered to compare the related work is the
existence of a formal model for each commissioning solution. Indeed,
we claim that studying formally commissioning models and their
operational semantics is of high importance to open the door to
verification and safety in commissionings and by extension
reconfigurations. For instance, even if this contribution is not
presented in this paper, the formal model \mad has been
successfully used to verify safety properties on distributed software
commissionings by model checking~\cite{coullon:hal-02323641}.

%----------------------------
\subsection{Description and comparison of the related work}
% ----------------------------

% Shell-scripts
\paragraph{Shell scripts}
The traditional way operators automate software commissioning is by
transcribing the actions and configurations from README files and tutorials
into a sequence of commands in \shell scripts. On the one hand, those
scripts are written with low-level imperative languages, and with good
programming skills, it is possible to express complex workflows (\eg
idempotency, parallelism, remote actions using SSH). For
instance, parallelism can be managed by combining command execution in
the background (\eg using the control operator \& in \bash) and
synchronisation commands like \emph{wait}. On the other hand, as the
system grows, any custom script becomes error-prone, unpredictable,
hard to understand and to maintain. \shell scripts lack software
engineering aspects and there is no framework to express modules or
tasks and their dependencies, thus making separation of concerns a very
tricky work. In Table~\ref{tab:comparison} we indicate that each
metric introduced could potentially be implemented manually by using
\shell. Of course, such mechanisms are difficult to implement, error
prone, and time consuming.
% devstack is a set of shell script to deploy OpenStack on a single machine

\paragraph{Fractal}
Component-based software engineering (CBSE) is a domain that enhances
(distributed) software implementation by dealing with code re-use,
separation of concerns, and composability (thus maintainability) of
software~\cite{Szyperski:2002:CSB:515228}. A component-based
application is composed of a set of component instances connected
together. Such composition of components is called an
\emph{assembly}. A component is a black box that implements an
independent functionality of an application, and that interacts with
other components through well defined interfaces, called \emph{ports}.
Ports are used to decouple the component internals from its
interface. For instance, a port can be used to declare that the
component either provides a service ---in this case the port is
attached to an internal method--- or uses a service from another
component. Many component models focus on the implementation of the
functionalities and
interfaces~\cite{corba:omg06,Blair2009,baude:hal-01001043,Bernholdt01052006,bigot:inria-00388508,Coullon2017}
of components, rather than on their commissioning. A few component
models have contributed to commissioning issues. In the Object
Management Group's (OMG) specification~\cite{ccmdeploy:omg06}, the
commissioning model is rigid and fixed by the model. In
\fractal~\cite{Blair2009} and its evolutions GCM and
GCM/ProActive~\cite{baude:hal-01001043}, the control of a component
(\eg its commissioning) is decoupled from its functionalities into a
so called \emph{membrane} which is itself described as a component
assembly written in Java. The membrane is handled by the \fractal
runtime but the sub-assembly and its associated codes are entirely
left to the user. That is why in Table~\ref{tab:comparison}, metrics
not natively supported by \fractal can be handled manually using
java. Both \emph{separation of concerns} and \emph{inter-comp} are well
handled by \fractal thanks to the notion of port (dependencies within
the component or with an external component) adapted to the
membrane. One can note that only \fractal components commissionings
can be written in the membrane, thus if writing the commissioning of
existing modules they have to be encapsulated in a \fractal component.

% Deployware
\paragraph{Deployware}
\citeauthor{flissi2008ccgrid} proposed \deployware (DW) as a research
effort to distributed software commissioning in the context of Grid
computing~\cite{flissi2008ccgrid}. Its implementation is based on the
\fractal component model. A component is called a \emph{Personality}
and is associated with a fixed set of commissioning actions (install,
configure, start, manage, stop, unconfigure and uninstall),
which can be considered as a fixed set of \emph{tasks}.  Each action
describes a sequence of tasks, written with a specific high-level
language that uses pre-defined instructions (\eg execute command, copy
a file). While there is no notion of component ports, it is possible
to express dependencies between components to initiate automatic
coordination. For instance, when the operator triggers the action
"install" on a component, the same action is triggered recursively to
its dependencies. As they are not entirely controllable by the user,
metrics \emph{tasks}, \emph{SIMH} and \emph{inter-comp} are considered
partially supported by \deployware. Finally, as \deployware is
based on \fractal and as a formal effort has been carried out on \fractal,
the formal aspect of \deployware is considered partially supported.

% Ansible
\paragraph{Ansible}
For the DevOps who are used to shell scripts, \ansible has become a
popular configuration management tool since it relies on a simple
syntax written in YAML and does not require agents on administrated
servers. Tasks are managed using only SSH and
Python which are commonly installed on every Linux
distribution.  In comparison, similar tools like \chef, \puppet or
\cfengine not only require at least a slight understanding of Ruby or
a custom language to get started, but they are built on an agent-based
architecture and require prior agent commissioning on remote hosts.
\ansible features software engineering aspects such as separation of
concerns by defining the notion of \emph{roles}, which can be seen as
software components.  Each role contains a set of files that describe
a sequence of tasks. To define a composition, a specific file called
an \ansible \emph{playbook} is used for mapping the desired roles to
the groups of nodes they will be applied to. Those groups of nodes are
defined in a separate file called the \emph{inventory}. When \ansible
is triggered, roles and their related tasks are sequentially executed
to the associated groups of nodes. While tasks declarations are indeed
managed sequentially, each task is executed in parallel when mapped to
multiple remote hosts thus leading to the \emph{SIMH} metric.
Typically, an operator who wants to commission an \apache web server
and a \mysql database would download two roles from Ansible Galaxy and
register them in a playbook. Since \ansible triggers roles in a
sequential manner, if the operator is not aware that the database must
be commissioned before the web server, she could make a mistake in the
order of the roles she declared. This aspect makes the
\emph{separation of concerns} metric only partially
supported. Finally, as one of the possible types of tasks in \ansible
is the execution of a \shell command, any script could be executed as
a task, thus making it possible to handle manually the \emph{intra-comp-tasks}
parallelism level.

% Tasks are declared in an imperative way, however, Ansible relies heavily on
% declarative modules, most of which ensure task idempotency (operations are run
% once even if called multiple times).

% Aeolus
\paragraph{Aeolus}
\citeauthor{dicosmo2014ic} proposed \aeolus, a formal component-based
model for the cloud~\cite{dicosmo2014ic}. Their component model
captures the internal states of a component commissioning process
thanks to a finite state machine. Each state can be connected to use,
provide, or conflict ports to declare dependencies between the
commissioning steps of different components. Hence, such ports enable
coordination of the global deployment process.

% Juju
\paragraph{Juju}
Canonical has developed their own software commissioning solution,
\juju (\url{https://jujucharms.com/}), which aims at commissioning any
kind of application on top of different cloud providers (\eg AWS,
OpenStack), and on multiple types of resources (container, VM or
bare-metal). Its concepts are close to those of component models. Software
modules are packaged as \juju \emph{charms} that describe the
software commissioning steps through a set of scripts called
\emph{hooks}. Operators define their composition in a specific file
called \emph{bundle} in which they declare the desired charms with
their \emph{relations}. A relation is an element declared between two
charms and used for component synchronization (by triggering hooks)
and data sharing at runtime, similarly to component ports. As the
concepts behind \juju are very close to those of \aeolus, the same
metrics are available barring the formal aspect.
% good soc, download charms and run juju deploy

\paragraph{TOSCA}
The \emph{Topology and Orchestration Specification for Cloud
  Applications} (TOSCA) is another component-oriented model that
partially addresses the task of commissioning of its
components. TOSCA~\cite{tosca:web,brogi2018} is a
standardization effort from OASIS to describe Cloud applications,
their components and their deployment artifacts, using standard
languages (\ie XML, YAML). A TOSCA description (or template)
corresponds to a graph where nodes represent TOSCA resources
(\eg software components, virtual machines, physical servers), and
where edges represent the relations between these nodes. Artifacts (of
any type: scripts, executable etc.) can be added to TOSCA descriptions
in a CSAR (Cloud Service ARchive) to detail commissioning steps. Those
commissioning steps can thus be customized by the developper, but there
is no model, nor any guarantees associated to them. Thus, \emph{tasks} and
\emph{intra-comp-tasks} metrics could be handled manually by the user. As
there is no way to declare dependencies between artifacts of
components, the \emph{inter-taks} metric is not supported, however,
relations between components make both \emph{SIMH} and
\emph{inter-comp} metrics theoretically available in \tosca. No
information has been found on the complete support of these metrics
in \tosca implementations~\cite{cloudify:web,opentosca:web}. Finally,
some efforts have been carried out to formally define the \tosca
standard~\cite{tosca:web}.

% Kubernetes
\paragraph{Kubernetes}
Initiated by Google, \kubernetes (K8S) is a popular framework to
commission distributed software in the form of micro-services that are
packaged as a hierarchy of Docker containers and \emph{pods}. A
software component in \kubernetes is thus defined as a Docker
container. Such components have no ports to manage coordination, and
their internals are fixed, since containers can only be started and
stopped. As a consequence, the commissioning process is
error-prone. For instance, a web server can be started before the
required database and thus fail. For this reason, the metric
\emph{inter-comp} is considered partially supported.
% depend_on exists but limited to "container is started"
% synchronization is possible but must be managed by internal script and not managed by k8s
% good soc, download containers and run k8s deploy but without synchonization,
    % commissioning is error-prone

\begin{table*}[tp]
  \centering
  \small
  \input{tables/tab_related_work.tex}
  \caption{Comparison of commissioning solutions based on aspects
  regarding parallelism (performance) and software engineering (SE).}
  \label{tab:comparison}
\end{table*}

%----------------------------
\subsection{Discussions}
%----------------------------
% 3. discussion
% - flexibility vs automation vs formal
% - separation of concerns
% - intra-task parallelism
% - performance model and formal

In the previous section, eight different related works have been
compared according to software engineering metrics, parallelism
metrics and one metric regarding the formal definition of the
considered solution. Table~\ref{tab:comparison} summarizes this
comparison and raises a few key points that we discuss in the
following section.

As usual when working on programming languages, the existing
tools illustrate the difficult trade-off between flexibility and
automation. On the one hand, when the tool is highly programmable,
developers have the ability to manage their own code organization and
to handle any kind of software engineering or efficiency property. For
instance, by using \shell, any of the introduced metrics could be
handled. However, each of them would have to be hand-coded, which is
difficult and error prone. On the other hand, some existing solutions
such as \deployware and \juju restrict the internal commissioning
behavior of components to a fixed set of actions (\eg install,
configure, start). This choice has the advantage of guaranteeing the
full control of the automated parallelism level but also restricts
potential optimizations due to the specificity of each component and
the interactions between components and their tasks.

One can note that \aeolus is the solution with the highest score
regarding the introduced metrics. Indeed, \aeolus combines advantages
of component models to structure the code of software commissionings
and enhance its separation of concerns, while introducing an
additional way to model the internal commissioning behavior of each
component through tasks. It seems that \aeolus offers a good trade-off
between flexibility and automation. However, while offering the best
combination of metrics, \aeolus handles the separation of
concerns between components only partially.

Furthermore, one can note that no existing solution offers a full
support for \emph{intra-comp-tasks} parallelism level. Actually, although a few
existing solutions already offer a way to model the internal
commissioning behavior of each component by using tasks, dependencies
between those tasks are limited to a sequential imperative order, thus
making \emph{intra-comp-tasks} parallelism impossible. Such parallelism
could be handled manually by some of the existing tools, however such
parallel aspects are difficult to implement and error prone, thus they
should be handled automatically.

If introducing more parallelism opens up additional performance
capabilities, it also introduces more complexity for the user. For
this reason, formalizing the commissioning solution is of high
importance to guarantee properties such as attainability of
commissionings.

\begin{tcolorbox}[enhanced,attach boxed title to top left={yshift=-3mm,yshifttext=-1mm},
  colback=black!5!white,colframe=black!30,colbacktitle=black!60,
  title=Contribution,fonttitle=\bfseries,
  boxed title style={size=small,colframe=black!60,boxrule=0.2mm},
  boxrule=0.2mm]
  \mad is a formal component model inpired by \aeolus that enhances
  the automation, the separation of concerns and the parallelism level
  of distributed software commissionings.
\end{tcolorbox}

% One further aspect of the level of programmability provided by commissioning
% tools. When the tool is highly programmable, developers have the ability to
% manage their own code organization. This is an important aspect to finely
% express what can be executed in parallel (thus it impacts performance). For
% instance \deployware and \juju limit the internals of their modules to a
% predefined set of actions (eg config, install) while such actions might contain
% instructions that can be declared parallelable.
% %
% Our solution differs by letting developers abstract a set of instructions in the
% form of transitions. Transitions can be expressed in parallel, and their
% synchronisation is declared using states.
% %high programmable can also  improve maintainability by isolating specfic code
% %in a transition.

% Finally, a desired feature for distributed software commissioning is automation.
% Typically an operator should download the desired modules to compose a
% distributed software, instantiate and connect them through their ports, then run
% the commissioning process. This aspect requires an operational semantic to
% express how the commissioning process automatically progresses with respect to
% inter and intra-component dependencies. For instance, \aeolus, which supports
% only inter-component parallelism, is a component-based model that relies on
% states and transitions to manage inter-component dependencies. However, since
% the model lacks an operational semantic, each operation is planned and executed
% by an external scheduler. In this work, one of our contribution is to provide a
% operational semantic which drives the execution of the distributed software
% commissioning, and will be explained in \cref{subsec:operational_semantics}.

% As depicted in~\cref{tab:comparison}, we can conclude from this analysis that
% individually, none of the above attempts adequately provide a commissioning tool
% which can express both a high-degree of parallelism and feature software
% engineering aspects like separation of concerns.
% In the rest of this paper, we define \mad, our contribution which is inspired by
% \aeolus as a component-based model and relies on modules and ports to express all
% the parallelism levels described above. In the rest of the paper, we will
% focus the comparison of our solution with \ansible and \aeolus, since the former
% is widely used in production, while the second is a research effort that
% provides most of the above features.

