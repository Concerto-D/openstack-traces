% 1. introduce metrics of RW
% - soft. eng., composition, code reuse, sep of concerns
% - parallelism levels
% 2. RW analyze
% - each tool
% - table
% 3. discussion
% - intra-task
% - performance model

%----------------------------
\subsection{Related work metrics}
%----------------------------
% 1. software engineering
% - components / service / module
% - sub-elements / tasks
% - separation of concerns when assembling 2 components, no need to
% know what each component does to commission itself
% 2. parallelism
% - node / SIMH
% - inter-component
% - inter-task
% - intra-task
% 3. formalism
% - formal model

Before introducing the related work of this paper, some analysis
metrics need to be introduced. These metrics are divided in three
sets: software engineering (SE) metrics, metrics related to the
parallelism level of commissionings, and metrics related to formal
aspects of commissionings. For each metric four levels will be
considered and presented in Table~\ref{tab:comparison}: (1) supported,
denoted with \checkmark, that counts for 3 points in the score; (2)
partially supported, denoted (\checkmark), that counts for 2 points;
(3) manually supported, denoted \emph{M}, meaning that the user may
code manually the given metric, and that counts 1 point; and finally
(4) not supported, denoted -.

\paragraph{Software engineering}
As introduced in the previous section, when automating distributed
software commissionings one important aspect is to promote software
engineering properties. Indeed, when different actors are involved in
a same given goal, software engineering techniques can help improving
separation of concerns (\ie code reuse, maintainability
etc.). Separation of concerns means that each actor is responsible for
her own specialism, \ie her own expertise domain. Such separation of
concerns is improved as soon as a modular or component-based approach
is adopted, \ie each actor could be responsible for one
component. Furthermore, component-based architectures are also equiped
with composition mechanisms that ease the interactions between the
different entities implemented by different actors. One additional
actor may also enter the picture to design this composition. We define
three SE metrics to compare the related work:
\begin{itemize}
\item \emph{component}: if the work (tool, framework or scientific
  contribution) offers a component-oriented (\eg services, modules)
  structure of commissionings;
\item \emph{tasks}: if the work (tool, framework or scientific
  contribution) offers a way to divide the commissioning of each
  component in sub-elements that we call \emph{tasks} and that promote
  even more a well structured procedural design;
\item \emph{separation of concerns}: if the work (tool, framework or
  scientific contribution) offers a way to build distributed software
  commissionings by composing each commissioning of individual
  components and while not needing to know their internal behaviors.
\end{itemize}

\paragraph{Parallelism level}
A second important aspect of distributed software commissioning that
has been introduced in the previous section is its efficiency and in
particular (in this paper) the level of parallelism offered by
commissioning tools and frameworks. We consider four metrics to
compare the related work:
\begin{itemize}
\item \emph{SIMH}: if the work offers a transparent way to perform the
  same instruction or set of instructions on multiple hosts
  simultaneously, meaning that there are no dependencies between the
  instructions to perform on the different hosts;
  \item \emph{inter-comp}: if the work offers a transparent way to
    simultaneously execute the commissionings of multiple components
    if no dependency exists between those components;
  \item \emph{inter-comp-tasks}: if the work offers a transparent way to
    simultaneously execute the commissioning tasks of multiple
    components until a dependency between multiple tasks is reached;
  \item \emph{intra-comp-tasks}: if the work offers a way to simultaneously
    execute two commissioning tasks of a given component, in other
    words if a partial order of tasks can be given for a component.
\end{itemize}
One can note that the level of parallelism offered by a given tool is
directly correlated to the type of dependencies that can be declared
by users. For instance, without any dependency mechanisms the best
possible level would be SIMH, while with inter-components dependencies
or \emph{inter-comp-tasks} dependencies more parallelism can be
handled between components of different types.

\HC[Helene]{Add figures to explain the four parallelism levels}

One can note that presented metrics for both SE and parallelism are
procedural-oriented as they consider \emph{tasks} and not
\emph{resources}, thus excluding \puppet or \salt for instance. While
being an approach with great advantages, declarative approaches are
not considered in this paper.

\paragraph{Formalism}
The last metric considered to compare the related work is the
existence of a formal model for each commissioning solution. Indeed,
we claim that studying formally commissioning models and their
operational semantics is of high importance to open the door to
verification and safety in commissionings and by extension
reconfigurations. For instance, even if this contribution is not
presented in this paper, the formal model \mad has been
successfully used to verify safety properties on distributed software
commissionings by model checking~\cite{coullon:hal-02323641}.

%----------------------------
\subsection{Description and comparison of the related work}
% ----------------------------

Among the plethora of distributed software commissioning solutions, we
have selected a subpart of them for a deeper comparison. According to
the classification of Section~\ref{sec:context}, we have selected: two
\emph{coding} or scripting solutions, \shell and \fractal; three
procedural-oriented solutions of the \emph{software configuration}
class, \ansible, \deployware and \aeolus; two solutions of the
\emph{infrastructure definition} class, \juju and \tosca; and finally
one \emph{orchestration} solution, \kubernetes. In this selection we
have taken a particular attention to select both production tools and
academic contributions. Moreover, we have selected production tools
having a significant opensource community.

% Shell-scripts
\paragraph{Shell scripts}
The traditional way operators automate software commissioning is by
transcribing the actions and configurations from READMEs and tutorials
into a sequence of commands in \shell scripts. On the one hand, those
scripts are written with low-level imperative languages, and with good
programming skills, it is possible to express complex workflows (\eg
idempotency, parallelism, remote actions using \textsc{SSH}). For
instance, parallelism can be managed by combining command execution in
the background (\eg using the control operator \& in \bash) and
synchronisation commands like \emph{wait}. On the other hand, as the
system grows, any custom script becomes error-prone, unpredictable,
hard to understand and to maintain. \shell scripts lack of software
engineering aspects and there is no framework to express modules nor
tasks and their dependencies thus making separation of concerns a very
tricky work. In Table~\ref{tab:comparison} we indicate that each
metric introduced could potentially be implemented manually by using
\shell. Of course, such mechanisms are difficult to implement, error
prone, and time consuming.
% devstack is a set of shell script to deploy OpenStack on a single machine

\paragraph{Fractal}
Component-based software engineering (CBSE) is a domain that enhances
(distributed) software implementation by dealing with code re-use,
separations of concerns, and composability (thus maintainability) of
software codes~\cite{Szyperski:2002:CSB:515228}. A component-based
application is composed of a set of component instances connected
together. Such composition of components is called an
\emph{assembly}. A component is a black box that implements an
independent functionality of an application, and which interacts with
other components through well defined interfaces, called \emph{ports}.
Ports are used to decouple the component internals from its
interface. For instance, a port can be used to declare that the
component either provides a service ---in this case the port is
attached to an internal method--- or use a service from another
component. Many component models focus on the implementation of the
functionalities and
interfaces~\cite{corba:omg06,Blair2009,baude:hal-01001043,Bernholdt01052006,bigot:inria-00388508,Coullon2017}
of components, rather than on their commissioning. A few component
models have contributed to commissioning issues. In the Object
Management Group's (OMG) specification~\cite{ccmdeploy:omg06}, the
commissioning model is rigid and fixed by the model. In
\fractal~\cite{Blair2009} and its evolutions GCM and
GCM/ProActive~\cite{baude:hal-01001043}, the control of a component
(\eg its commissioning) is decoupled from its functionalities into a
so called \emph{membrane} which is itself described as a component
assembly written in java. The membrane is handled by the \fractal
runtime but the sub-assembly and its associated codes are entirely
left to the user. That is why in Table~\ref{tab:comparison}, metrics
not natively supported by \fractal can be handled manually using
java. Both \emph{sparation of concerns} and \emph{inter-comp} are well
handled by \fractal thanks to the notion of port (dependencies within
the component or with an external component) adapted to the
membrane. One can note that only \fractal components commissionings
can be written in the membrane, thus if writing the commissioning of
existing modules they have to be encapsulated in a \fractal component.

% Deployware
\paragraph{Deployware}
\citeauthor{flissi2008ccgrid} proposed \deployware (DW) as a research
effort to distributed software commissioning in the context of Grid
computing~\cite{flissi2008ccgrid}. Its implementation is based on the
\fractal component model. A component is called a \emph{Personality}
and is associated to a fixed set of commissioning actions (\ie
install, configure, start, manage, stop, unconfigure and uninstall),
which can be considered as a fix set of \emph{tasks}.  Each action
describes a sequence of tasks, written with a specific high-level
language that uses pre-defined instructions (\eg execute command, copy
a file). While there is no notion of component ports, it is possible
to express dependencies between components to initiate automatic
coordination. For instance, when the operator triggers the action
"install" on a component, the same action is triggered recursively to
its dependencies. As theyr are not entirely controllable by the user,
metrics \emph{tasks}, \emph{SIMH} and \emph{inter-comp} are considered
as partially supported by \deployware. Finally, as \deployware is
based on \fractal and as a formal effort have been done on \fractal,
the formal aspect of \deployware is considered partially supported.

% Ansible
\paragraph{Ansible}
For the DevOps that are used to shell-scripts, \ansible has become a
popular configuration management tool since it relies on a simple
syntax written in YAML and does not require agents on administrated
servers. Tasks are indeed managed using only \textsc{SSH} and
\textsc{Python} which are commonly installed on every Linux
distributions.  In comparison, similar tools like \chef, \puppet or
\cfengine not only require at least a slight understanding of Ruby or
a custom language to get started, but they are built on an agent-based
architecture and requires prior agent commissioning on remote hosts.
\ansible features software engineering aspects like separation of
concerns by defining the notion of \emph{roles} which can be seen as
software components.  Each role contains a set of files that describe
a sequence of tasks. To define a composition, a specific file called
an \ansible \emph{playbook} is used for mapping the desired roles to
the groups of nodes they will be applied to. Those groups of nodes are
defined in a separate file called the \emph{inventory}. When \ansible
is triggered, roles and their related tasks are sequentially executed
to the associated groups of nodes. While tasks declarations are indeed
manages sequentially, each task is executed in parallel when mapped to
multiple remote hosts thus leading to the \emph{SIMH} metric.
Typically, an operator who wants to commission an \apache web server
and a \mysql database would download two roles from Ansible Galaxy and
register them in an playbook. Since \ansible triggers roles in a
sequential manner, if the operator is not aware that the database must
be commissioned before the web server, she could make a mistake in the
order of the roles she declared. This aspect makes the
\emph{separation of concerns} metric only partially
supported. Finally, as one of the possible type of tasks in \ansible
is the execution of a \shell command, any script could be executed as
a task thus making possible to handle manually the \emph{intra-comp-tasks}
parallelism level.

% Tasks are declared in an imperative way, however, Ansible relies heavily on
% declarative modules, most of which ensure task idempotency (operations are run
% once even if called multiple times).

% Aeolus
\paragraph{Aeolus}
\citeauthor{dicosmo2014ic} proposed \aeolus: a formal component-based
model for the cloud~\cite{dicosmo2014ic}. Their component model
captures the internal states of a component commissioning process
thanks to a finite state machine. Each state can be connected to use,
provide, or conflict ports to declare dependencies between the
commissioning steps of different components. Hence, such ports enable
the coordination of the global deployment process.

% Juju
\paragraph{Juju}
Canonical has developed their own software commissioning solution:
\juju (\url{https://jujucharms.com/}) which aims at commissioning any
kind of application on top of different cloud providers (\eg AWS,
OpenStack), and on multiple types of resources (container, VM or
bare-metal). Its concepts are close to component models. Software
modules are packaged as \juju \emph{charms} which describe the
software commissioning steps through a set of scripts called
\emph{hooks}. Operators define their composition in a specific file
called \emph{bundle} in which they declare the desired charms with
their \emph{relations}. A relation is an element declared between two
charms and used for component synchronization (by triggering hooks)
and data sharing at runtime, similarly to component ports. As the
concepts behind \juju are very close to the one of \aeolus the same
metrics are available except the formal aspect.
% good soc, download charms and run juju deploy

\paragraph{TOSCA}
The \emph{Topology and Orchestration Specification for Cloud
  Applications} (TOSCA) is another component-oriented model that
partially addresses the commissioning of its
components. TOSCA~\cite{tosca:web,10.1007/978-3-319-74781-1_33} is a
standardization effort from OASIS to describe Cloud applications,
their components and their deployment artifacts, using standard
languages (\ie XML, YAML). A TOSCA description (or template)
corresponds to a graph where nodes represent TOSCA resources
(e.g. software components, virtual machines, physical servers), and
where edges represent the relations between those nodes. Artifacts (of
any type: scripts, executable etc.) can be added to TOSCA descriptions
in a CSAR (Cloud Service ARchive) to detail commissioning steps. Those
commissioning steps can thus be customized by the developper but there
is no model and guarantees associated to them. Thus \emph{tasks} and
\emph{intra-comp-tasks} metrics could handled manually by the user. As
there is no way to declare dependencies between artifacts of
components the \emph{inter-taks} metric is not supported, however,
relations between components make both \emph{SIMH} and
\emph{inter-comp} metrics theoretically available in \tosca. No
information have been found on the complete support of these metrics
in \tosca implementations~\cite{cloudify:web,opentosca:web}. Finally,
come efforst have been done to formally define the \tosca
standard~\cite{tosca:web}.

% Kubernetes
\paragraph{Kubernetes}
Initiated by Google, \kubernetes (K8S) is a popular framework to
commission distributed software in the form of micro-services that are
packaged as a hierarchy of Docker containers and \emph{pods}. A
software component in \kubernetes is thus defined as Docker
container. Such components have no port to manage coordination, and
its internals is fixed since containers can only be started and
stopped. As a consequence, the commissioning process is
error-prone. For instance, a web server can be started before the
required database and thus fails. For this reason, the metric
\emph{inter-comp} is considered as partially supported.
% depend_on exists but limited to "container is started"
% synchronization is possible but must be managed by internal script and not managed by k8s
% good soc, download containers and run k8s deploy but without synchonization,
    % commissioning is error-prone

\begin{table*}[tp]
  \centering
  \small
  \input{tables/tab_related_work.tex}
  \caption{Comparison of commissioning solutions based on aspects
  regarding parallelism (performance) and software engineering (SE).}
  \label{tab:comparison}
\end{table*}

%----------------------------
\subsection{Discussions}
%----------------------------
% 3. discussion
% - flexibility vs automation vs formal
% - separation of concerns
% - intra-task parallelism
% - performance model and formal

In the previous section, eight different related works have been
compared according to software engineering metrics, parallelism
metrics and one metric regarding the formal definition of the
considered solution. Table~\ref{tab:comparison} resumes this
comparison and raises a few key points that we discuss in the
following.

As usual when working on programming languages, the existing
tools illustrate the difficult trade-off between flexibility and
automation. On the one hand, when the tool is highly programmable,
developers have the ability to manage their own code organization and
to handle any kind of software engineering or efficiency property. For
instance, by using \shell, any of the introduced metrics could be
handled. However, each of them would have to be hand-coded which is
difficult and error prone. On the other hand, some existing solutions
such as \deployware and \juju restrict the internal commissioning
behavior of components to a fix set of actions (\eg install,
configure, start). Such choice has the advantage of guaranteeing the
full control of the automated parallelism level but also restrict
potential optimizations due to the specificity of each component and
the interactions between components and their tasks.

One can note that \aeolus is the solution with the highest score
regarding the introduced metrics. Indeed, \aeolus combines advantages
of component models to structure the code of software commissionings
and enhance its separation of concerns, while introducing an
additional way to model the internal commissioning behavior of each
component through tasks. It seems that \aeolus offers a good trade-off
between flexibility and automation. However, while offering the best
combination of metrics, \aeolus partially handle separation of
concerns between components.

Furthermore, one can note that no existing solution offers a full
support for \emph{intra-comp-tasks} parallelism level. Actually, if a few
existing solutions already offer a way to model the internal
commissioning behavior of each component by using tasks, dependencies
between those tasks are limited to a sequential imperative order thus
making \emph{intra-comp-tasks} parallelism impossible. Such parallelism
could be handled manually by some of the existing tools, however such
parallel aspects are difficult to implement and error prone, thus they
should be handled automatically.

If introducing more parallelism opens up additional performance
capabilities, it also introduces more complexity for the user. For
this reason, formalizing the commissioning solution is of high
importance to guarantee properties such as attainability of
commissionings.

\begin{tcolorbox}[enhanced,attach boxed title to top left={yshift=-3mm,yshifttext=-1mm},
  colback=black!5!white,colframe=black!30,colbacktitle=black!60,
  title=Contribution,fonttitle=\bfseries,
  boxed title style={size=small,colframe=black!60,boxrule=0.2mm},
  boxrule=0.2mm]
  \mad is a formal component model inpired by \aeolus that enhances
  the automation, the separation of concerns and the parallelism level
  of distributed software commissionings.
\end{tcolorbox}

% One further aspect of the level of programmability provided by commissioning
% tools. When the tool is highly programmable, developers have the ability to
% manage their own code organization. This is an important aspect to finely
% express what can be executed in parallel (thus it impacts performance). For
% instance \deployware and \juju limit the internals of their modules to a
% predefined set of actions (eg config, install) while such actions might contain
% instructions that can be declared parallelable.
% %
% Our solution differs by letting developers abstract a set of instructions in the
% form of transitions. Transitions can be expressed in parallel, and their
% synchronisation is declared using states.
% %high programmable can also  improve maintainability by isolating specfic code
% %in a transition.

% Finally, a desired feature for distributed software commissioning is automation.
% Typically an operator should download the desired modules to compose a
% distributed software, instantiate and connect them through their ports, then run
% the commissioning process. This aspect requires an operational semantic to
% express how the commissioning process automatically progresses with respect to
% inter and intra-component dependencies. For instance, \aeolus, which supports
% only inter-component parallelism, is a component-based model that relies on
% states and transitions to manage inter-component dependencies. However, since
% the model lacks an operational semantic, each operation is planned and executed
% by an external scheduler. In this work, one of our contribution is to provide a
% operational semantic which drives the execution of the distributed software
% commissioning, and will be explained in \cref{subsec:operational_semantics}.

% As depicted in~\cref{tab:comparison}, we can conclude from this analysis that
% individually, none of the above attempts adequately provide a commissioning tool
% which can express both a high-degree of parallelism and feature software
% engineering aspects like separation of concerns.
% In the rest of this paper, we define \mad, our contribution which is inspired by
% \aeolus as a component-based model and relies on modules and ports to express all
% the parallelism levels described above. In the rest of the paper, we will
% focus the comparison of our solution with \ansible and \aeolus, since the former
% is widely used in production, while the second is a research effort that
% provides most of the above features.

