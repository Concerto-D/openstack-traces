%This paper focuses on one specific challenge related to distributed
%software deployment: \emph{distributed software commissioning}. By
%software commissioning we mean the complete installation,
%configuration and testing process when deploying distributed software
%on physical distributed resources, with or without a virtualization
%layer in between. This process is complex and error-prone because of
%the specificity of the installation process according to the operating
%system, the different kinds of virtualization layers used between the
%physical machines and the pieces of software, the amount of possible
%configuration options~\cite{Xu:2015:SAT:2775083.2791577}. Recently,
%commissioning (or configuration) management tools such as
%Ansible\footnote{\url{https://www.ansible.com/}}, or
%Puppet\footnote{\url{https://puppet.com}}, have been widely adopted by
%system operators. These tools commonly include good
%software-engineering practices such as code reuse and composition in
%management and configuration scripts. It is nowadays possible to build
%a new installation by assembling different pieces of existing
%installations\footnote{\url{https://galaxy.ansible.com/}}\footnote{\url{https://forge.puppet.com/}}
%which improves the productivity of system operators and prevents many
%errors. Many distributed software commissioning are nowadays written
%with one the three above tools and by using containers between the
%host operating system and the pieces of software, such that
%portability of installations is improved. For instance, OpenStack,
%which is the de-facto open source operating system of Cloud
%infrastructures, can be automatically installed on clusters by using
%the
%\href{https://docs.openstack.org/kolla-ansible/latest/}{\emph{kolla-ansible}
%  project}, which uses both Docker containers and Ansible.
%
%Yet, even for such well-established software, there is still much room
%for improving the efficiency of the commissioning process (\ie
%reducing deployment times, minimizing services interruptions etc.).


In contrast to monolithic software that runs locally on a single machine, distributed software is designed in a modular architectural style where each entity (\ie module, component, or service or micro-service) is responsible for a specific part of the overall objective, and collaborates at runtime with other entities that are potentially hosted on distant nodes (\ie machines). In the rest of this paper we will use the generic term \emph{component} to refer indifferently to a module, a service or a micro-service. Distributed software have become commonplace in our day-to-day life, sometimes hosted on the Cloud, on personal computers, on mobile phones, on objects etc. 

However, deploying a large distributed software on infrastructures is a tedious task where components have to be chosen and mapped to the nodes of infrastructures, where components have to be chosen and configured, where dependencies have to be solved, where virtualization layers have to be handled etc. Furthermore, such procedure involves many different actors with different expertise and roles which increase the difficulty of the overall process: (1) \emph{developers} who are responsible for designing and coding a set of components or services; (2) \emph{sysadmins} and \emph{sysops} responsible for up-keeping, configuring, and testing multi-users computer systems such as servers or Clouds, and (3) in between \emph{devops} engineers that work with software developers, system operators (SysOps) and other production IT staff to oversee code releases and deployments. For these reasons, deployment procedures have to be automated and need adapted programming support (\ie languages, models).

In this paper, among the difficulties related to the deployment of distributed software systems, we left apart the mapping between pieces of software and the nodes of the infrastructure, which is the result of an optimization problem and not in the scope of this paper~\cite{6409358, 10.1007/978-3-319-47677-3_15, cadorel:hal-02165835, ccgridemile, 10.5555/2432523.2432528}. Indeed, we restrict the scope of this paper to the \emph{software-commissioning} part of the deployment, \ie the procedure responsible for leading the set of components to a valid running state while guaranteeing correct configurations and interactions.
%
In particular, three metrics are considered important regarding the quality of
the automation of distributed software commissioning in this paper: (1) a clear separation of concerns between the different actors of the commissioning procedure (\ie developers, sysadmins and devops) to enhance productivity, maintainability
and re-usability of deployment codes; (2) the efficiency of the commissioning procedure in terms of parallelism expressiveness; and (3) the formalization of the solution such that formal properties can be proven on a given commissioning procedure. The contribution of this paper improves the related work by succeeding in the combination of these three metrics.
%

In~\cite{chardet:hal-01858150} we have presented a formal model for distributed software commissioning, namely \mad, that theoretically improves the parallelism
level exposed to the user. This journal paper brings the following additional
contributions compared to our previous publication: 
\begin{itemize} 
	\item an extended study of the related work; 
	\item a revised and streamlined \mad formal	model that offers stronger guarantees; 
	\item a theoretical performance prediction model of \mad; 
	\item a concrete language and a prototype;
	\item an extended reproducible evaluation on both synthetic use-cases and one large real use-case on real infrastructures.
\end{itemize}

%%% outline
The rest of this paper is organized as follows. Section~\ref{sec:motivation} presents the detailed motivations of the contribution. Section~\ref{sec:related_work} studies the related work. Section~\ref{sec:mad_model} gives an overview of \mad as well as its concrete language. Sections~\ref{sec:formal_model} and~\ref{sec:perf_model} respectively detail the formalization of \mad as well as its associated performance prediction model. Sections~\ref{sec:evaluations} and~\ref{sec:use-cases} respectively present an evaluation of the \mad prototype on synthetic use-cases and an evaluation of the contribution interests on the real use-case of OpenStack commissioning.  Finally, Section~\ref{sec:conc} concludes and gives some perspectives.




